{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Building a simple MVC system with PHP7 and higher Abstract This tutorial was written based on another (simpler) tutorial written by Dennis Pallett in PHPit.com. The framework which we have at the end is fully working but we advice against using it in production as we miss a lot of security features. Introduction In this tutorial you will learn how to build a simple Model-View- Controller system with PHP 7 and some of SPL's (Standard PHP Library) features. I'll take you through all the steps necessary to start from scratch to a full-blown MVC system. We will look not only at MVC but at other common design patterns as well. Folders In our little system we will create the following folders, we will create them when needed: classes Here will be our base classes plus the framework. controllers Here will be our controllers which handle the data between the models and the views. models In this we will place our models that are the basis for our data. The model defines the data and how it is saved. views In here we have our view files, we use them to present the data and information to the user. The view (or multiple views) is what you see when you visit a website. One point of entry One of the important things about our MVC system is that it will have only a single point of entry. Instead of having several dozens of PHP files that do the following: <?php include('global.php'); // Rest of the actual page code here We will have a single page that handles all the requests. This means we won't have to include a global.php every time we want to create a new page. This \"single point of entry\" page will be called 'index.php' and, at the moment, looks like this: <?php // Do something As you can see, the index page does nothing yet, but it will in a minute. To make sure that all the requests go to the index page we will setup an .htaccess RewriteRule using the mod_rewrite engine. Put the following code in a file called \".htaccess\" in the same directory as the index.php file: RewriteEngine on RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule ^(.*)$ index.php?route=$1 [L,QSA] First we check if the actual file exists using the RewriteCond command, and if it doesn't exist, we redirect it through the index.php file. We have to check if the file exists, because we also want to be able to use regular non-PHP files, such as JPEG images. If you can't use .htaccess or mod_rewrite, you will have to manually redirect the requests through the index.php file, which means all your links must be in the form of \"index.php?route=[request-goes- here]\", e.g. index.php?route=chat/index. Now that all the requests are going through a single point of entry, we can start writing the index.php file. The first thing we will have to do is some startup tasks. Create a new file called 'startup.php' in the root directory. Put the following code in the index.php file: # Startup tasks (define constants, etc) require 'startup.php'; Startup Tasks The startup file is used to do some general startup tasks, like defining constants, setting the error reporting level, etc. The first part of our startup file looks like this: <?php error_reporting(E_ALL); if(version_compare(phpversion(), '7.0.0', '<') == true){die('PHP7.0 or newer'); } // Constants: define('DIRSEP', DIRECTORY_SEPARATOR); // Get site path $site_path = realpath(dirname(__FILE__) . DIRSEP) . DIRSEP; define('site_path', $site_path); In the above example we define some constants, get the site path, and also check to make sure that the current PHP version is at least 7.0. The Registry Note The registry design pattern is used here because it is very simple to understand. Today you would see more often a Service Manager or other similar design patterns. The next thing we'll have to do is setup a Registry object to hold all our global data. A registry object is passed around all the individual objects in our MVC system, and is used to transport global data through out the system without having to use the 'global' keyword or $GLOBALS. Read \"Using globals in PHP\" for more information on the registry object. Add the following code to the startup.php file, below the code from the previous example: $registry = new Registry; If you now try to run the system, you should get the following error: Fatal error: Class 'Registry' not found in demo/startup.php on line 12 Not really a surprise, since we haven't created the Registry class yet, nor have we included a file that contains the Registry class. We could simply include it using the include() function, but let's use one of PHP5's new features: __autoload(). The __autoload() magic function is used to dynamically load classes. Whenever PHP encounters a non-existent class, it will first call a custom __autoload() function, and only then declare an error. This can be used to load classes on-the-fly. Put one of the following codes before the previous code example: // For loading classes function custom_autoload($class_name) { $filename = strtolower($class_name) . '.php'; $file = site_path . 'classes' . DIRSEP . $filename; if(file_exists($file) == false){ return false; } include($file); } spl_autoload_register('custom_autoload'); Our custom_autoload() function takes the class name, passed as an argument, and checks if a similar named file exists in the classes directory. If the file doesn't exist, the function will simply return false and a fatal error will still show up, but if the file does exist, it will be included, which means the class is suddenly there, and no error is thrown. For it to work we need to define the custom_autoload with sql_autoload_register(custom_autoload). We haven't created the Registry class yet, which means we still get an error, so let's do something about that. Creating the Registry class The Registry class is used to pass global data around between the individual objects, and is actually a really simple class, and needs no more than three small methods. First, create a new directory called 'classes', and then create a new file called 'registry.php'. Put the following code in the registry.php file: <?php Class Registry { private $vars = array(); } We now have a skeleton for the Registry class, and all we need to do is add some methods. All the Registry class needs is a set() method, to set data, and a get() method, to get data. Optionally we can also add a remove() method to remove some data. The following three methods will do, and should be added to the Registry class: function set($key, $var){ if (isset($this->vars[$key]) == true) { throw new Exception('Unable to set var `' . $key . '`. Already set.'); } $this->vars[$key] = $var; return true; } function get($key) { if(isset($this->vars[$key]) == false) { return null; } return $this->vars[$key]; } function remove($var){ unset($this->vars[$key]); } As you can see, these three methods are really basic, and all they do is set, get and unset items from the $vars property. In the set() method we also check if data with that particular key doesn't already exist, and if it does, we throw an exception. This is to protect from accidentally overwriting data. We now have a fully functional Registry class, but we aren't going to stop here. We're going to use one of SPL's features: ArrayAccess. SPL, which is short for the Standard PHP Library, is a collection of interfaces and classes that are meant to solve standard problems. One of SPL's interfaces, ArrayAccess, can be used to give array access to an object. Consider the following code snippet, do not integrate it: <?php $registry = new Registry; // Set some data $registry->set ('name', 'Dennis Pallett'); // Get data, using get() echo $registry->get('name'); // Get data, using array access echo $registry['name'] The array access makes it seem that $registry is an array, even though it's an object. Although ArrayAccess has not real advantages, it means less typing since you don't have to continuously use ->get(). To use ArrayAccess you will first have to change the first line of the class (\"Class Registry\"), which becomes: Class Registry implements ArrayAccess { The Implements keyword is used to implement an interface, and that's exactly what ArrayAccess is. By implementing the ArrayAccess interface, the class must also add four new methods: function offsetExists($offset) { return isset($this->vars[$offset]); } function offsetGet($offset) { return$this->get($offset); } function offsetSet($offset, $value) { $this->set($offset, $value); } function offsetUnset($offset) { unset($this->vars[$offset]); } These methods should be fairly self-explanatory, and more information can be found in the SPL documentation. Now that we have implemented ArrayAccess, we can use the object just like an array, as you saw in the previous example and in the following example: <?php $registry = new Registry; // Set some data $registry->['name'] = 'MVC Tutorial'; // Get data, using get() echo $registry->get('name'); // Get data, using array access echo $registry['name'] Our Registry class is now finished, and if you try to run the system everything should work (although nothing is displayed yet). Our start up file is finished, and we can move to the next step of our MVC system: setting up the database functionality, also called the \"Model\". The Model The 'M' or model part of the MVC system is responsible for querying the database (or another external source) and providing the data to the controller. We could have the appropriate model loaded depending on the request, but I prefer to blur the lines between the model and the controller, whereby the controller uses a DB abstraction library to directly query the DB, instead of having a separate model. One thing we must do is add the code necessary to setup up a connection with the database, and add it to our index page. There are many great DB abstraction libraries available but PHP5 and higher comes with a great DB library already - PDO - so there's no need for a different library. Put the following code in the global.php in the root folder. <?php $db = new PDO('mysql:host=localhost; dbname=demo', '[user]', '[password]'); $registry->set('db', $db); Now we include the global.php in our index.php file in our root folder. # Connect to DB include 'global.php'; In the above example we first create a new instance of the PDO library, and connect to our MySQL database. We then make the $db global, by using our Registry class. We won't need that for this tutorial bit it's important because we would need it later if we want to get data from a database, like with any other MVC System. The global.php should be diffrent from system to system so that no sensitive data leaves you development environment. Creating a sample model Now if we want our program to use data that we deliver, we need to implement a class like Member. This is our Model. The Model represents the data that gets posted to the Controller. In our example we want give out a member name. So we need our model the possibility to hold information. For this we create a new folder in our root directory called \"models\". Then we create a new file called Model_Member.php in it. <?php /** * Model_Member */ class Model_Member { private $firstname; private $lastname; /** * __construct * * @param string $firstname * @param string $lastname * @return void */ public function __construct(string $firstname, string $lastname) { $this->firstname = $firstname; $this->lastname = $lastname; } /** * getFirstname * * @return String */ public function getFirstname() : String { return $this->firstname; } /** * getLastname * * @return String */ public function getLastname() : String { return $this->lastname; } /** * setFirstname * * @param string $firstname * @return void */ public function setFirstname(string $firstname) { $this->firstname = $firstname; } /** * setLastname * * @param string $lastname * @return void */ public function setLastname(string $lastname) { $this->lastname = $lastname; } } To give and receive information we use functions called getter and setter. Like our getter getFirstname will return the String that was saved if called. With our setters like setLastname we can give it a String and it will be saved in the object. Some words about DocBlocks As you might have noticed the code has PHP Doc Comment added. These comments add information about our functions in our code. We can later read it out and generate a code documentation if we want to. It describes what a function needs (@param) and what it might return (@return). Doc Comments always start with /* and end with /. The model part of our system is pretty much finished for now, so let's move on to the next part: writing the controller. Writing the controller also means we will have to write a Router class first. A Router class is responsible for loading the correct controller, based on the request (the $router variable passed through the URL). Let's write the Router class first. The Router class Our Router class will have to analyse the request, and then load the correct command/action (method) from the right controller. We will create a new Router.php file in our classes folder. First step is to create a basic skeleton for the router class: <?php Class Router { private $registry; private $path; private $args = array(); function __construct($registry){ $this->registry = $registry; } } And then add the following lines to the index.php file: # Load router $router = new Router($registry); $registry->set('router', $router); We've now added the Router class to our MVC system, but it doesn't do anything yet, so let's add the necessary methods to the Router class. The first thing we will want to add is a setPath() method, which is used to set the directory where we will holdall our controllers. The setPath() method looks like this, and needs to be added to the Router class: function setPath($path){ $path = trim($path, '/\\\\'); $path .= DIRSEP; if(is_dir($path) == false) { throw new Exception ('Invalid controller path: `' . $path . '`'); } $this->path = $path; } Note When using a Unix filesystem change trim=($path, '/\\'); to trim=($path, '\\'); . Then add the following line to the index.php file: $router->setPath(site_path . 'controllers'); Now that we've set the path to our controllers, we can write the actual method responsible for loading the correct controller. This method will be called delegate(), and will analyse the request. The first bit of this method looks like this: function delegate(){ // Analyse route $this->getController($file, $controller, $action, $args); As you can see, it uses another method, getController() to get the controller name, and a few other variables. This method looks like this: /** * getController * * @param mixed $file * @param mixed $controller * @param mixed $action * @param mixed $args * @return void */ private function getController(&$file, &$controller, &$action, &$args) { $route = (empty($_GET['route'])) ? '' : $_GET['route']; if(empty($route)){$route = 'index'; } // Get separate parts $route = trim($route, '\\\\'); $parts = explode('/', $route); // Find right controller $cmd_path = $this->path; foreach($parts as $part){ $fullpath = $cmd_path .'Controller_'. $part; // Is there a dir with this path? if(is_dir($fullpath)){ $cmd_path .= $part . DIRSEP; array_shift($parts); continue; } // Find the file if(is_file($fullpath . '.php')){ $controller = $part; array_shift($parts); break; } } if(empty($controller)){$controller = 'index';}; // Get action $action = array_shift($parts); if(empty($action)){$action = 'index'; } $args = $parts; $file = $cmd_path . 'Controller_'. $controller . '.php'; $this->registry->set('args', $args); } Let's go through this method. It first gets the value of the $route query string variable, and then proceeds to split it into separate parts, using the explode() function. If the request is 'members/view' it would split it into array('members', 'view'). We then use a foreach loop to walk through each part, and first check if the part is a directory. If it is, we add it to the filepath and move to the next part. This allows us to put controllers in sub- directories, and use hierarchies of controllers. If the part is not a directory, but a file, we save it to the $controller variable, and exit the loop since we've found the controller that we want. After the loop we first make sure that a controller has been found, and if there is no controller we use the default one called 'index'. We then proceed to get the action that we need to execute. The controller is a class that consists of several different methods, and the action points to one of the methods. If no action is specified, we use the default action called 'index'. Lastly, we get the full file path of the controller by concatenating the path, controller name and the extension. Now that the request has been analysed it's up to the delegate() method to load the controller and execute the action. The complete delegate() method looks like this: function delegate() { // Analyze route $this->getController($file, $controller, $action, $args); // File available? if(is_readable($file) == false) { die('404 Not Found'); } // Include the file include($file); // Initiate the class $class = 'Controller_' . $controller; $controller = new$class($this->registry); // Action available? if(is_callable(array($controller, $action)) == false) { die('404 Not Found'); } // Run action $controller->$action(); } After having analysed the request with the getController() method, we first make sure that the file actually exists, and if it doesn't we return an simple error message. The next thing we do is include the controller file, and then initiate the class, which should always be called Controller_[name]. We'll learn more about the controller later on. Then we check if the action exists and is executable by using the is_callable() function. Lastly, we run the action, which completes the role of the router. Now that we have a fully working delegate() method, add the following line to the index.php file: $router->delegate(); If you now try to run the system, you will either get the following error, if you haven't yet created the 'controllers' directory: Fatal error: Uncaught exception 'Exception' with message 'Invalid controller path: `demo\\controllers\\` in demo\\classes\\router.php:18 Stack trace: #0 \\demo\\index.php(13): Router->setPath('demo\\...') #1 {main} thrown in demo\\classes\\router.php on line 18 Or you will get the '404 Not Found' error, because there are no controllers yet. But that's what we're going to create right now. The Controller The controller part of our MVC system is actually very simple, and requires very little work. First, make sure that the 'controllers' directory exists. Then, create a new file called 'controller_base.php' in the 'classes' directory, and put the following code in it: <?php Abstract Class Controller_Base { protected $registry; function __construct($registry){ $this->registry = $registry; } abstract function index(); } This abstract class will be the parent class for all our controllers, and it does only two things: saves a copy of the Registry class and makes sure that all our controllers have an index() method. Now let's create our first controller. Create a new file called 'Controller_Index.php' in the 'controllers' directory, and add the following code to it: <?php Class Controller_Index Extends Controller_Base { function index() { echo 'Hello from my MVC system'; } } We've now created our first controller, and if you try to run our MVC system now, you should see the following: This means that our Router class did the job, and executed the correct controller and action. Let's create another controller that corresponds to a request that looks like 'members/view'. Create a new file called 'controller_members.php' in a newly created controllers directory, and add the following code to it: <?php Class Controller_Members Extends Controller_Base { function index(){ echo 'Default index of the `members` controllers'; } function view() { echo 'You are viewing the members/view request'; } } Now go to your MVC system, and make sure that the request is 'members/view', either by directly going there or by going to index.php?route=members/view. You should get the following result: Just by creating a new controller class and adding a method we've been able to define a whole new page in our MVC system, and we didn't have to change anything else in our system. Our controllers don't need to include a 'global.php' file or anything like it whatsoever. Now that we've got the controller part working in our MVC system, there's only one thing left: the 'V' or View part of our MVC system. The View Just like the Model, there are several different ways of doing the View part of our MVC system. We could use the Router to automatically load another file called something like 'view_{name}.php', but to keep this tutorial simple, we'll create a custom View class, which can be used to show views. First, create a new file called 'view.php' in the 'classes' directory, and put the following code in it: <?php Class View { private $registry; private $vars = array(); function __construct($registry) { $this->registry = $registry; } } As you can see, we've now got the basic structure of our View class. The next step is to add the following code to our index.php file, before the Router statements: # Load view object $view = new View($registry); $registry->set('view', $view); Because we want to use data from the model and controller in our views, we will have to write a set() method to make variables available in the view. See the example below: function set($varname, $value, $overwrite = false){ if(isset($this->vars[$varname]) == true AND $overwrite == false) { trigger_error('Unable to set var `' . $varname . '`. Already set, and overwrite not allowed.',E_USER_NOTICE); return false; } $this->vars[$varname] = $value; return true; } function remove($varname) { unset($this->vars[$varname]); return true; } As you can see, the set() and remove() methods are fairly simple methods, used to set and remove a variable. Now that we can set variables, all we need to write is the show() method, used for showing views. The easiest way is to create a separate directory called 'views', which holds all our view files, and then using an include() call to show a view. Of course your show() method can be completely different, and load the views from the database or do something else. See the code snippet below for the show()method we'll be using: function show($name){ $path = site_path . 'views' . DIRSEP . $name . '.php'; if(file_exists($path) == false) { trigger_error('View `' . $name . '` does not exist.', E_USER_NOTICE); return false; } // Load variables foreach($this->vars as $key => $value) { $$key = $value; } include($path); } Our View class is now complete, and can be used to display views in the controller. For example,create a new file called 'index_page.php' in the 'views' directory, and put the following code in it: Hello from the View, <?php echo $first_name . \" \". $last_name;?>! Then, in the index controller (under controllers/index.php): function index() { $firstname = 'Peter'; $lastname = 'Meier'; $model_data = new Model_Member($firstname, $lastname); // Set the model into the registry $this->registry->set('member',$model_data); // Get some values from the model $this->registry['view']->set('first_name', $this->registry->get('member')->getFirstname()); $this->registry['view']->set('last_name', $this->registry->get('member')->getLastname()); // Render now the page to the user $this->registry['view']->show('index_page'); } Here we set the parts of the name and then create a new object with \"new\" and give it the parts of the name. Then we save our new member object in our registy. After that we give the view the information with set, so we set parameters for first and lastname taken from our saved object in the registry. Note Normally the data would come from a data base and not be written down in the controller, we wouldn't use the registry either, but for this tutorial we will use it this way just once as a demonstration. If you now browse to our MVC system, you should get the following: Now that we've got an active View component, our MVC system is complete, and can be used to create a full-blown website. But there are a few small things we have to take care of still. Also move the router.php from the root folder to the classes folder. Security Measures At the moment all the sub-directories, such as 'controllers' and 'views', are still publicly available to anyone who wants to visit it. This could mean that users start running controllers or views that should only be run by our system, so let's block access to those directories. With the .htaccess file this is really easy, and all it takes is the following command: Deny from ALL Put the above command in a new file called .htaccess, and save this file in the 'controllers' and 'views' directory (and any other directory you want to protect). This will make sure that these directories are completely off limits for everyone.","title":"Building a simple MVC system with PHP7 and higher"},{"location":"#building-a-simple-mvc-system-with-php7-and-higher","text":"","title":"Building a simple MVC system with PHP7 and higher"},{"location":"#abstract","text":"This tutorial was written based on another (simpler) tutorial written by Dennis Pallett in PHPit.com. The framework which we have at the end is fully working but we advice against using it in production as we miss a lot of security features.","title":"Abstract"},{"location":"#introduction","text":"In this tutorial you will learn how to build a simple Model-View- Controller system with PHP 7 and some of SPL's (Standard PHP Library) features. I'll take you through all the steps necessary to start from scratch to a full-blown MVC system. We will look not only at MVC but at other common design patterns as well.","title":"Introduction"},{"location":"#folders","text":"In our little system we will create the following folders, we will create them when needed: classes Here will be our base classes plus the framework. controllers Here will be our controllers which handle the data between the models and the views. models In this we will place our models that are the basis for our data. The model defines the data and how it is saved. views In here we have our view files, we use them to present the data and information to the user. The view (or multiple views) is what you see when you visit a website.","title":"Folders"},{"location":"#one-point-of-entry","text":"One of the important things about our MVC system is that it will have only a single point of entry. Instead of having several dozens of PHP files that do the following: <?php include('global.php'); // Rest of the actual page code here We will have a single page that handles all the requests. This means we won't have to include a global.php every time we want to create a new page. This \"single point of entry\" page will be called 'index.php' and, at the moment, looks like this: <?php // Do something As you can see, the index page does nothing yet, but it will in a minute. To make sure that all the requests go to the index page we will setup an .htaccess RewriteRule using the mod_rewrite engine. Put the following code in a file called \".htaccess\" in the same directory as the index.php file: RewriteEngine on RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule ^(.*)$ index.php?route=$1 [L,QSA] First we check if the actual file exists using the RewriteCond command, and if it doesn't exist, we redirect it through the index.php file. We have to check if the file exists, because we also want to be able to use regular non-PHP files, such as JPEG images. If you can't use .htaccess or mod_rewrite, you will have to manually redirect the requests through the index.php file, which means all your links must be in the form of \"index.php?route=[request-goes- here]\", e.g. index.php?route=chat/index. Now that all the requests are going through a single point of entry, we can start writing the index.php file. The first thing we will have to do is some startup tasks. Create a new file called 'startup.php' in the root directory. Put the following code in the index.php file: # Startup tasks (define constants, etc) require 'startup.php';","title":"One point of entry"},{"location":"#startup-tasks","text":"The startup file is used to do some general startup tasks, like defining constants, setting the error reporting level, etc. The first part of our startup file looks like this: <?php error_reporting(E_ALL); if(version_compare(phpversion(), '7.0.0', '<') == true){die('PHP7.0 or newer'); } // Constants: define('DIRSEP', DIRECTORY_SEPARATOR); // Get site path $site_path = realpath(dirname(__FILE__) . DIRSEP) . DIRSEP; define('site_path', $site_path); In the above example we define some constants, get the site path, and also check to make sure that the current PHP version is at least 7.0.","title":"Startup Tasks"},{"location":"#the-registry","text":"Note The registry design pattern is used here because it is very simple to understand. Today you would see more often a Service Manager or other similar design patterns. The next thing we'll have to do is setup a Registry object to hold all our global data. A registry object is passed around all the individual objects in our MVC system, and is used to transport global data through out the system without having to use the 'global' keyword or $GLOBALS. Read \"Using globals in PHP\" for more information on the registry object. Add the following code to the startup.php file, below the code from the previous example: $registry = new Registry; If you now try to run the system, you should get the following error: Fatal error: Class 'Registry' not found in demo/startup.php on line 12 Not really a surprise, since we haven't created the Registry class yet, nor have we included a file that contains the Registry class. We could simply include it using the include() function, but let's use one of PHP5's new features: __autoload(). The __autoload() magic function is used to dynamically load classes. Whenever PHP encounters a non-existent class, it will first call a custom __autoload() function, and only then declare an error. This can be used to load classes on-the-fly. Put one of the following codes before the previous code example: // For loading classes function custom_autoload($class_name) { $filename = strtolower($class_name) . '.php'; $file = site_path . 'classes' . DIRSEP . $filename; if(file_exists($file) == false){ return false; } include($file); } spl_autoload_register('custom_autoload'); Our custom_autoload() function takes the class name, passed as an argument, and checks if a similar named file exists in the classes directory. If the file doesn't exist, the function will simply return false and a fatal error will still show up, but if the file does exist, it will be included, which means the class is suddenly there, and no error is thrown. For it to work we need to define the custom_autoload with sql_autoload_register(custom_autoload). We haven't created the Registry class yet, which means we still get an error, so let's do something about that.","title":"The Registry"},{"location":"#creating-the-registry-class","text":"The Registry class is used to pass global data around between the individual objects, and is actually a really simple class, and needs no more than three small methods. First, create a new directory called 'classes', and then create a new file called 'registry.php'. Put the following code in the registry.php file: <?php Class Registry { private $vars = array(); } We now have a skeleton for the Registry class, and all we need to do is add some methods. All the Registry class needs is a set() method, to set data, and a get() method, to get data. Optionally we can also add a remove() method to remove some data. The following three methods will do, and should be added to the Registry class: function set($key, $var){ if (isset($this->vars[$key]) == true) { throw new Exception('Unable to set var `' . $key . '`. Already set.'); } $this->vars[$key] = $var; return true; } function get($key) { if(isset($this->vars[$key]) == false) { return null; } return $this->vars[$key]; } function remove($var){ unset($this->vars[$key]); } As you can see, these three methods are really basic, and all they do is set, get and unset items from the $vars property. In the set() method we also check if data with that particular key doesn't already exist, and if it does, we throw an exception. This is to protect from accidentally overwriting data. We now have a fully functional Registry class, but we aren't going to stop here. We're going to use one of SPL's features: ArrayAccess. SPL, which is short for the Standard PHP Library, is a collection of interfaces and classes that are meant to solve standard problems. One of SPL's interfaces, ArrayAccess, can be used to give array access to an object. Consider the following code snippet, do not integrate it: <?php $registry = new Registry; // Set some data $registry->set ('name', 'Dennis Pallett'); // Get data, using get() echo $registry->get('name'); // Get data, using array access echo $registry['name'] The array access makes it seem that $registry is an array, even though it's an object. Although ArrayAccess has not real advantages, it means less typing since you don't have to continuously use ->get(). To use ArrayAccess you will first have to change the first line of the class (\"Class Registry\"), which becomes: Class Registry implements ArrayAccess { The Implements keyword is used to implement an interface, and that's exactly what ArrayAccess is. By implementing the ArrayAccess interface, the class must also add four new methods: function offsetExists($offset) { return isset($this->vars[$offset]); } function offsetGet($offset) { return$this->get($offset); } function offsetSet($offset, $value) { $this->set($offset, $value); } function offsetUnset($offset) { unset($this->vars[$offset]); } These methods should be fairly self-explanatory, and more information can be found in the SPL documentation. Now that we have implemented ArrayAccess, we can use the object just like an array, as you saw in the previous example and in the following example: <?php $registry = new Registry; // Set some data $registry->['name'] = 'MVC Tutorial'; // Get data, using get() echo $registry->get('name'); // Get data, using array access echo $registry['name'] Our Registry class is now finished, and if you try to run the system everything should work (although nothing is displayed yet). Our start up file is finished, and we can move to the next step of our MVC system: setting up the database functionality, also called the \"Model\".","title":"Creating the Registry class"},{"location":"#the-model","text":"The 'M' or model part of the MVC system is responsible for querying the database (or another external source) and providing the data to the controller. We could have the appropriate model loaded depending on the request, but I prefer to blur the lines between the model and the controller, whereby the controller uses a DB abstraction library to directly query the DB, instead of having a separate model. One thing we must do is add the code necessary to setup up a connection with the database, and add it to our index page. There are many great DB abstraction libraries available but PHP5 and higher comes with a great DB library already - PDO - so there's no need for a different library. Put the following code in the global.php in the root folder. <?php $db = new PDO('mysql:host=localhost; dbname=demo', '[user]', '[password]'); $registry->set('db', $db); Now we include the global.php in our index.php file in our root folder. # Connect to DB include 'global.php'; In the above example we first create a new instance of the PDO library, and connect to our MySQL database. We then make the $db global, by using our Registry class. We won't need that for this tutorial bit it's important because we would need it later if we want to get data from a database, like with any other MVC System. The global.php should be diffrent from system to system so that no sensitive data leaves you development environment.","title":"The Model"},{"location":"#creating-a-sample-model","text":"Now if we want our program to use data that we deliver, we need to implement a class like Member. This is our Model. The Model represents the data that gets posted to the Controller. In our example we want give out a member name. So we need our model the possibility to hold information. For this we create a new folder in our root directory called \"models\". Then we create a new file called Model_Member.php in it. <?php /** * Model_Member */ class Model_Member { private $firstname; private $lastname; /** * __construct * * @param string $firstname * @param string $lastname * @return void */ public function __construct(string $firstname, string $lastname) { $this->firstname = $firstname; $this->lastname = $lastname; } /** * getFirstname * * @return String */ public function getFirstname() : String { return $this->firstname; } /** * getLastname * * @return String */ public function getLastname() : String { return $this->lastname; } /** * setFirstname * * @param string $firstname * @return void */ public function setFirstname(string $firstname) { $this->firstname = $firstname; } /** * setLastname * * @param string $lastname * @return void */ public function setLastname(string $lastname) { $this->lastname = $lastname; } } To give and receive information we use functions called getter and setter. Like our getter getFirstname will return the String that was saved if called. With our setters like setLastname we can give it a String and it will be saved in the object. Some words about DocBlocks As you might have noticed the code has PHP Doc Comment added. These comments add information about our functions in our code. We can later read it out and generate a code documentation if we want to. It describes what a function needs (@param) and what it might return (@return). Doc Comments always start with /* and end with /. The model part of our system is pretty much finished for now, so let's move on to the next part: writing the controller. Writing the controller also means we will have to write a Router class first. A Router class is responsible for loading the correct controller, based on the request (the $router variable passed through the URL). Let's write the Router class first.","title":"Creating a sample model"},{"location":"#the-router-class","text":"Our Router class will have to analyse the request, and then load the correct command/action (method) from the right controller. We will create a new Router.php file in our classes folder. First step is to create a basic skeleton for the router class: <?php Class Router { private $registry; private $path; private $args = array(); function __construct($registry){ $this->registry = $registry; } } And then add the following lines to the index.php file: # Load router $router = new Router($registry); $registry->set('router', $router); We've now added the Router class to our MVC system, but it doesn't do anything yet, so let's add the necessary methods to the Router class. The first thing we will want to add is a setPath() method, which is used to set the directory where we will holdall our controllers. The setPath() method looks like this, and needs to be added to the Router class: function setPath($path){ $path = trim($path, '/\\\\'); $path .= DIRSEP; if(is_dir($path) == false) { throw new Exception ('Invalid controller path: `' . $path . '`'); } $this->path = $path; } Note When using a Unix filesystem change trim=($path, '/\\'); to trim=($path, '\\'); . Then add the following line to the index.php file: $router->setPath(site_path . 'controllers'); Now that we've set the path to our controllers, we can write the actual method responsible for loading the correct controller. This method will be called delegate(), and will analyse the request. The first bit of this method looks like this: function delegate(){ // Analyse route $this->getController($file, $controller, $action, $args); As you can see, it uses another method, getController() to get the controller name, and a few other variables. This method looks like this: /** * getController * * @param mixed $file * @param mixed $controller * @param mixed $action * @param mixed $args * @return void */ private function getController(&$file, &$controller, &$action, &$args) { $route = (empty($_GET['route'])) ? '' : $_GET['route']; if(empty($route)){$route = 'index'; } // Get separate parts $route = trim($route, '\\\\'); $parts = explode('/', $route); // Find right controller $cmd_path = $this->path; foreach($parts as $part){ $fullpath = $cmd_path .'Controller_'. $part; // Is there a dir with this path? if(is_dir($fullpath)){ $cmd_path .= $part . DIRSEP; array_shift($parts); continue; } // Find the file if(is_file($fullpath . '.php')){ $controller = $part; array_shift($parts); break; } } if(empty($controller)){$controller = 'index';}; // Get action $action = array_shift($parts); if(empty($action)){$action = 'index'; } $args = $parts; $file = $cmd_path . 'Controller_'. $controller . '.php'; $this->registry->set('args', $args); } Let's go through this method. It first gets the value of the $route query string variable, and then proceeds to split it into separate parts, using the explode() function. If the request is 'members/view' it would split it into array('members', 'view'). We then use a foreach loop to walk through each part, and first check if the part is a directory. If it is, we add it to the filepath and move to the next part. This allows us to put controllers in sub- directories, and use hierarchies of controllers. If the part is not a directory, but a file, we save it to the $controller variable, and exit the loop since we've found the controller that we want. After the loop we first make sure that a controller has been found, and if there is no controller we use the default one called 'index'. We then proceed to get the action that we need to execute. The controller is a class that consists of several different methods, and the action points to one of the methods. If no action is specified, we use the default action called 'index'. Lastly, we get the full file path of the controller by concatenating the path, controller name and the extension. Now that the request has been analysed it's up to the delegate() method to load the controller and execute the action. The complete delegate() method looks like this: function delegate() { // Analyze route $this->getController($file, $controller, $action, $args); // File available? if(is_readable($file) == false) { die('404 Not Found'); } // Include the file include($file); // Initiate the class $class = 'Controller_' . $controller; $controller = new$class($this->registry); // Action available? if(is_callable(array($controller, $action)) == false) { die('404 Not Found'); } // Run action $controller->$action(); } After having analysed the request with the getController() method, we first make sure that the file actually exists, and if it doesn't we return an simple error message. The next thing we do is include the controller file, and then initiate the class, which should always be called Controller_[name]. We'll learn more about the controller later on. Then we check if the action exists and is executable by using the is_callable() function. Lastly, we run the action, which completes the role of the router. Now that we have a fully working delegate() method, add the following line to the index.php file: $router->delegate(); If you now try to run the system, you will either get the following error, if you haven't yet created the 'controllers' directory: Fatal error: Uncaught exception 'Exception' with message 'Invalid controller path: `demo\\controllers\\` in demo\\classes\\router.php:18 Stack trace: #0 \\demo\\index.php(13): Router->setPath('demo\\...') #1 {main} thrown in demo\\classes\\router.php on line 18 Or you will get the '404 Not Found' error, because there are no controllers yet. But that's what we're going to create right now.","title":"The Router class"},{"location":"#the-controller","text":"The controller part of our MVC system is actually very simple, and requires very little work. First, make sure that the 'controllers' directory exists. Then, create a new file called 'controller_base.php' in the 'classes' directory, and put the following code in it: <?php Abstract Class Controller_Base { protected $registry; function __construct($registry){ $this->registry = $registry; } abstract function index(); } This abstract class will be the parent class for all our controllers, and it does only two things: saves a copy of the Registry class and makes sure that all our controllers have an index() method. Now let's create our first controller. Create a new file called 'Controller_Index.php' in the 'controllers' directory, and add the following code to it: <?php Class Controller_Index Extends Controller_Base { function index() { echo 'Hello from my MVC system'; } } We've now created our first controller, and if you try to run our MVC system now, you should see the following: This means that our Router class did the job, and executed the correct controller and action. Let's create another controller that corresponds to a request that looks like 'members/view'. Create a new file called 'controller_members.php' in a newly created controllers directory, and add the following code to it: <?php Class Controller_Members Extends Controller_Base { function index(){ echo 'Default index of the `members` controllers'; } function view() { echo 'You are viewing the members/view request'; } } Now go to your MVC system, and make sure that the request is 'members/view', either by directly going there or by going to index.php?route=members/view. You should get the following result: Just by creating a new controller class and adding a method we've been able to define a whole new page in our MVC system, and we didn't have to change anything else in our system. Our controllers don't need to include a 'global.php' file or anything like it whatsoever. Now that we've got the controller part working in our MVC system, there's only one thing left: the 'V' or View part of our MVC system.","title":"The Controller"},{"location":"#the-view","text":"Just like the Model, there are several different ways of doing the View part of our MVC system. We could use the Router to automatically load another file called something like 'view_{name}.php', but to keep this tutorial simple, we'll create a custom View class, which can be used to show views. First, create a new file called 'view.php' in the 'classes' directory, and put the following code in it: <?php Class View { private $registry; private $vars = array(); function __construct($registry) { $this->registry = $registry; } } As you can see, we've now got the basic structure of our View class. The next step is to add the following code to our index.php file, before the Router statements: # Load view object $view = new View($registry); $registry->set('view', $view); Because we want to use data from the model and controller in our views, we will have to write a set() method to make variables available in the view. See the example below: function set($varname, $value, $overwrite = false){ if(isset($this->vars[$varname]) == true AND $overwrite == false) { trigger_error('Unable to set var `' . $varname . '`. Already set, and overwrite not allowed.',E_USER_NOTICE); return false; } $this->vars[$varname] = $value; return true; } function remove($varname) { unset($this->vars[$varname]); return true; } As you can see, the set() and remove() methods are fairly simple methods, used to set and remove a variable. Now that we can set variables, all we need to write is the show() method, used for showing views. The easiest way is to create a separate directory called 'views', which holds all our view files, and then using an include() call to show a view. Of course your show() method can be completely different, and load the views from the database or do something else. See the code snippet below for the show()method we'll be using: function show($name){ $path = site_path . 'views' . DIRSEP . $name . '.php'; if(file_exists($path) == false) { trigger_error('View `' . $name . '` does not exist.', E_USER_NOTICE); return false; } // Load variables foreach($this->vars as $key => $value) { $$key = $value; } include($path); } Our View class is now complete, and can be used to display views in the controller. For example,create a new file called 'index_page.php' in the 'views' directory, and put the following code in it: Hello from the View, <?php echo $first_name . \" \". $last_name;?>! Then, in the index controller (under controllers/index.php): function index() { $firstname = 'Peter'; $lastname = 'Meier'; $model_data = new Model_Member($firstname, $lastname); // Set the model into the registry $this->registry->set('member',$model_data); // Get some values from the model $this->registry['view']->set('first_name', $this->registry->get('member')->getFirstname()); $this->registry['view']->set('last_name', $this->registry->get('member')->getLastname()); // Render now the page to the user $this->registry['view']->show('index_page'); } Here we set the parts of the name and then create a new object with \"new\" and give it the parts of the name. Then we save our new member object in our registy. After that we give the view the information with set, so we set parameters for first and lastname taken from our saved object in the registry. Note Normally the data would come from a data base and not be written down in the controller, we wouldn't use the registry either, but for this tutorial we will use it this way just once as a demonstration. If you now browse to our MVC system, you should get the following: Now that we've got an active View component, our MVC system is complete, and can be used to create a full-blown website. But there are a few small things we have to take care of still. Also move the router.php from the root folder to the classes folder.","title":"The View"},{"location":"#security-measures","text":"At the moment all the sub-directories, such as 'controllers' and 'views', are still publicly available to anyone who wants to visit it. This could mean that users start running controllers or views that should only be run by our system, so let's block access to those directories. With the .htaccess file this is really easy, and all it takes is the following command: Deny from ALL Put the above command in a new file called .htaccess, and save this file in the 'controllers' and 'views' directory (and any other directory you want to protect). This will make sure that these directories are completely off limits for everyone.","title":"Security Measures"},{"location":"app/","text":"A simple Todo -App Now that we have our own MVC up and running we can start implementing functionality. We will create a Todo App to keep track of our notes and tasks. This Todo App can save new Notes, change existing ones and delete the one we don't need anymore. For ease of use we also change our naming convention. So first of all we change our existing files. Everything in the controllers folder gets the prefix \"Controller_\" i.e.: Controller_Index.php and everything in models folder gets the Prefix \"Model_\". Our classes in the \"classes\" folder stay as they are. Controller To access this new part of our App we need to set up a new controller. So when we open the the site with /Todolist at the end of our URL our router can find it and the controller can spring into action. The new controller is called Controller_Todolist.php and is placed in the controllers folder. We add the following code: Class Controller_Todo Extends Controller_Base { function index(){ $this->registry['view']->show('Todoentry_Page'); } } View Our Controller now calls a view called \"Todoitems_Page\", but we haven't had made this view yet so we have to make it. In the View folder we create a new file called \"Todoitems_Page\". Add the following line to the Todoitems_Page.php in our view folder: Hello from the new Todo view! Model Now to integrate our Model. We need to consider what our model shall hold in forms of data. We are making a todolist. We want to know what we wrote down as a todo and we want to know if it's done or not. So we need two variables, one is \"$content\" to hold what we write down and the other is \"$state\" to check a task when it's done. Of cause we also need $id, to handle saving the todoitem into a database. So we Create a new file called \"Model_Todo.php\" in our models folder and add the following: <?php class Model_Todoitem { private $id; private $content; private $state; /** * Get the value of id */ public function getId() { return $this->id; } /** * Set the value of id * * @return self */ public function setId($id) { $this->id = $id; return $this; } /** * Get the value of content */ public function getContent() { return $this->content; } /** * Set the value of content * * @return self */ public function setContent($content) { $this->content = $content; return $this; } /** * Get the value of state */ public function getState() { return $this->state; } /** * Set the value of state * * @return self */ public function setState($state) { $this->state = $state; return $this; } } As you see we don't have a constructor for this model. That is because our PDO object will do it for us. When we create an object from the database with the help of the PDO a constructor is call that fills in the attributes automatically. Intregrating the Model into the Controller If we want to use our model we need to expand upon our controller to handle our requests. Then we need to build a repository to handle the CRUD for App. We will also need a Repository wich we will do after the Controller is done. First we will expand the controller like this: Class Controller_Todolist extends Controller_Base { /** * index * * @return void */ function index(){ $repo = new Repository_Todoitem($this->registry); $entries = $repo->fetchAll(); $this->registry['view']->set('entries', $entries); $this->registry['view']->show('Todoitems_Page'); } /** * show * * @return void */ function show() { $repo = new Repository_Todoitem($this->registry); $entry = $repo->fetch((int)$this->registry->get('args')[0]); $this->registry['view']->set('id', $entry->getId()); $this->registry['view']->set('content', $entry->getContent()); $this->registry['view']->set('state', $entry->getState()); $this->registry['view']->show('Todoentry_Page'); } /** * add * * @return void */ function add() { $this->registry['view']->show('Todoentry_Add_Page'); if ($_SERVER['REQUEST_METHOD'] === 'POST'){ $repo = new Repository_Todoitem($this->registry); //state checkbox from vie Returns NULL if($_POST['state'] == NULL){ $_POST['state'] = 0; } if($repo->add($_POST)){ header('Location: http://' .$_SERVER[\"HTTP_HOST\"]. \"/Todolist\"); } } } /** * delete * * @return void */ function delete() { $repo = new Repository_Todoitem($this->registry); if($repo->delete($_POST['id'])){ header('Location: http://' .$_SERVER[\"HTTP_HOST\"]. \"/Todolist\"); } } /** * edit * * @return void */ function edit() { if ($_SERVER['REQUEST_METHOD'] === 'POST'){ $repo = new Repository_Todoitem($this->registry); if($_POST['state'] == NULL){ $_POST['state'] = 0; } if($repo->update($_POST)){ header('Location: http://' .$_SERVER[\"HTTP_HOST\"]. \"/Todolist\"); } } } } Fist we expand our index function to get all todoentries with the fetchall() function of our upcoming repository. Then we set our entries into our view to be able to display them. With our show function we want to get a single entry and display it on a separate page page that shows only the entry. So we fetch one entry with it's id and give the attributes that we want to display to the view. The add function will, as it says, add a new entry. For that we first call for the page to add an entry. Now, if we get a POST request we will set the state of our todoentry to 0 if we get NULL, because the HTML checkbox we use for our state gives us NULL when unchecked. Then we call add and give it our POST Request to fill in a Todoitem in the database. With delete we just give the id of our entry to the repository to find and delete the entry. The edit function is exactly like our add function with the only difference that we call the update function of our repository. Next up is our repository. Our repository lets us interact with our database. We create, read, update and delete (CRUD) an entry with the help of it. As we did with our controller we also create a abstract Class called \"Repository_Base\" in our classes folder: <?php Abstract Class Repository_Base{ protected $registry; /** * __construct * * @param mixed $registry * @return void */ function __construct($registry) { $this->registry = $registry; $this->db = $registry['db']; } } This class ensures that our repositories have access to the database connection, our PDO, at any point. Now create a new file called \"Repository_Todoitem.php\" in the models folder and add the following code: <?php Class Repository_Todoitem extends Repository_Base { /** * fetch * * @param int $id * @return object */ function fetch(int $id) : object { $query = 'SELECT `id`, `content`, `state` FROM `todo` WHERE `id` = :id'; $statement = $this->db->prepare($query); $result = $statement->execute([':id' => $id]); if ($statement->rowCount() === 0) { throw new OutOfRangeException(); } $todoItem = $statement->fetchObject('Model_Todoitem'); return $todoItem; } /** * fetchAll * * @return array */ function fetchAll() : array { $query = 'SELECT `id`, `content`, `state` FROM `todo`'; $statement = $this->db->prepare($query); $result = $statement->execute(); $rows = $this->db->query($query)->fetchAll(PDO::FETCH_CLASS, 'Model_Todoitem'); return $rows; } /** * add * * @param mixed $form * @return bool */ function add($form) : bool { $query = 'INSERT INTO `todo` SET `content` = :content, `state` = :state'; $statement = $this->db->prepare($query); $result = $statement->execute([ ':content' => $form['content'], ':state' => $form['state'] ]); return $result; } /** * delete * * @param mixed $id * @return bool */ function delete($id) : bool { $query = 'DELETE FROM `todo` WHERE `id` = :id'; $statement = $this->db->prepare($query); $result = $statement->execute([':id' => $id]); return $result; } /** * update * * @param mixed $form * @return bool */ function update($form) : bool{ $query = 'UPDATE `todo` SET `content` = :content, `state` = :state WHERE `id` = :id'; $statement = $this->db->prepare($query); $result = $statement->execute([ ':id' => $form['id'], ':content' => $form['content'], ':state' => $form['state'] ]); return $result; } } All we do here is basically prepre our different statements for our CRUD functionality. Than we either fetch our object or objects, fill them in and return them. Or we provide data to the statements and call upon the database to either update an entry or delete it with it's id. Making a functional View To now view our todos we need of cause the views to show them. For that I prepared three views. \"Todoitems_Page.php\" to view all of our entries. \"Todoentry_Page.php\" to view a single entry and edit or delete it. And \"Todoentry_Add_Page\" for making a new entry. Create these files in the views folder. Todoitems_Page: <!DOCTYPE html> <html lang=\"en\"> <head> <link rel=\"stylesheet\" href=\"/styles.css\"> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Todoitems</title> </head> <body> <?php foreach($entries as $entry) { if($entry->getState() == 1){ $done = '- done'; } else { $done = '- open'; } echo '<a class=\"box\" href=\"/Todolist/show/'.$entry->getId().'\">'.$entry- >getContent().' '.$done.'</a>'; } ?> <a href=\"/Todolist/add\">Neuer Eintrag</a> </body> </html> Todoentry_Page: <!DOCTYPE html> <html lang=\"en\"> <head> <link rel=\"stylesheet\" href=\"/styles.css\"> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Todoentry</title> </head> <body> <form method=\"POST\" action=\"/Todolist/edit/\" class=\"todoentry\"> <textarea id=\"todotext\" name=\"content\" rows=\"4\" cols=\"50\" autofocus><?php echo $content?></textarea> <span> done? <input type=\"checkbox\" name=\"state\" value=1 <?php if($state == 1) echo' checked' ?> > </span> <span> <input type=\"submit\" value=\"Save\"> <input type=\"hidden\" name=\"id\" value=\"<?=$id;?>\"> </span> </form> <form method=\"POST\" action=\"/Todolist/delete/\"> <input type=\"submit\" value=\"delete\"> <input type=\"hidden\" name=\"id\" value=\"<?=$id;?>\"> </form> </body> </html> Todoentry_Add_Page: <!DOCTYPE html> <html lang=\"en\"> <head> <link rel=\"stylesheet\" href=\"/styles.css\"> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>New Entry</title> </head> <body> <h1>New Todo</h1> <form method=\"POST\"> <fieldset> <label> <span> Content <textarea id=\"todotext\" name=\"content\" rows=\"4\" cols=\"50\" autofocus></textarea> </span> <br> <span> Status <input type=\"checkbox\" name=\"state\" value=o> </span> </label> </fieldset> <input type=\"submit\" value=\"Save\"> </form> </body> </html> Now we have every thing in place for the Todoapp to work.","title":"A simple Todo -App"},{"location":"app/#a-simple-todo-app","text":"Now that we have our own MVC up and running we can start implementing functionality. We will create a Todo App to keep track of our notes and tasks. This Todo App can save new Notes, change existing ones and delete the one we don't need anymore. For ease of use we also change our naming convention. So first of all we change our existing files. Everything in the controllers folder gets the prefix \"Controller_\" i.e.: Controller_Index.php and everything in models folder gets the Prefix \"Model_\". Our classes in the \"classes\" folder stay as they are.","title":"A simple Todo -App"},{"location":"app/#controller","text":"To access this new part of our App we need to set up a new controller. So when we open the the site with /Todolist at the end of our URL our router can find it and the controller can spring into action. The new controller is called Controller_Todolist.php and is placed in the controllers folder. We add the following code: Class Controller_Todo Extends Controller_Base { function index(){ $this->registry['view']->show('Todoentry_Page'); } }","title":"Controller"},{"location":"app/#view","text":"Our Controller now calls a view called \"Todoitems_Page\", but we haven't had made this view yet so we have to make it. In the View folder we create a new file called \"Todoitems_Page\". Add the following line to the Todoitems_Page.php in our view folder: Hello from the new Todo view!","title":"View"},{"location":"app/#model","text":"Now to integrate our Model. We need to consider what our model shall hold in forms of data. We are making a todolist. We want to know what we wrote down as a todo and we want to know if it's done or not. So we need two variables, one is \"$content\" to hold what we write down and the other is \"$state\" to check a task when it's done. Of cause we also need $id, to handle saving the todoitem into a database. So we Create a new file called \"Model_Todo.php\" in our models folder and add the following: <?php class Model_Todoitem { private $id; private $content; private $state; /** * Get the value of id */ public function getId() { return $this->id; } /** * Set the value of id * * @return self */ public function setId($id) { $this->id = $id; return $this; } /** * Get the value of content */ public function getContent() { return $this->content; } /** * Set the value of content * * @return self */ public function setContent($content) { $this->content = $content; return $this; } /** * Get the value of state */ public function getState() { return $this->state; } /** * Set the value of state * * @return self */ public function setState($state) { $this->state = $state; return $this; } } As you see we don't have a constructor for this model. That is because our PDO object will do it for us. When we create an object from the database with the help of the PDO a constructor is call that fills in the attributes automatically.","title":"Model"},{"location":"app/#intregrating-the-model-into-the-controller","text":"If we want to use our model we need to expand upon our controller to handle our requests. Then we need to build a repository to handle the CRUD for App. We will also need a Repository wich we will do after the Controller is done. First we will expand the controller like this: Class Controller_Todolist extends Controller_Base { /** * index * * @return void */ function index(){ $repo = new Repository_Todoitem($this->registry); $entries = $repo->fetchAll(); $this->registry['view']->set('entries', $entries); $this->registry['view']->show('Todoitems_Page'); } /** * show * * @return void */ function show() { $repo = new Repository_Todoitem($this->registry); $entry = $repo->fetch((int)$this->registry->get('args')[0]); $this->registry['view']->set('id', $entry->getId()); $this->registry['view']->set('content', $entry->getContent()); $this->registry['view']->set('state', $entry->getState()); $this->registry['view']->show('Todoentry_Page'); } /** * add * * @return void */ function add() { $this->registry['view']->show('Todoentry_Add_Page'); if ($_SERVER['REQUEST_METHOD'] === 'POST'){ $repo = new Repository_Todoitem($this->registry); //state checkbox from vie Returns NULL if($_POST['state'] == NULL){ $_POST['state'] = 0; } if($repo->add($_POST)){ header('Location: http://' .$_SERVER[\"HTTP_HOST\"]. \"/Todolist\"); } } } /** * delete * * @return void */ function delete() { $repo = new Repository_Todoitem($this->registry); if($repo->delete($_POST['id'])){ header('Location: http://' .$_SERVER[\"HTTP_HOST\"]. \"/Todolist\"); } } /** * edit * * @return void */ function edit() { if ($_SERVER['REQUEST_METHOD'] === 'POST'){ $repo = new Repository_Todoitem($this->registry); if($_POST['state'] == NULL){ $_POST['state'] = 0; } if($repo->update($_POST)){ header('Location: http://' .$_SERVER[\"HTTP_HOST\"]. \"/Todolist\"); } } } } Fist we expand our index function to get all todoentries with the fetchall() function of our upcoming repository. Then we set our entries into our view to be able to display them. With our show function we want to get a single entry and display it on a separate page page that shows only the entry. So we fetch one entry with it's id and give the attributes that we want to display to the view. The add function will, as it says, add a new entry. For that we first call for the page to add an entry. Now, if we get a POST request we will set the state of our todoentry to 0 if we get NULL, because the HTML checkbox we use for our state gives us NULL when unchecked. Then we call add and give it our POST Request to fill in a Todoitem in the database. With delete we just give the id of our entry to the repository to find and delete the entry. The edit function is exactly like our add function with the only difference that we call the update function of our repository. Next up is our repository. Our repository lets us interact with our database. We create, read, update and delete (CRUD) an entry with the help of it. As we did with our controller we also create a abstract Class called \"Repository_Base\" in our classes folder: <?php Abstract Class Repository_Base{ protected $registry; /** * __construct * * @param mixed $registry * @return void */ function __construct($registry) { $this->registry = $registry; $this->db = $registry['db']; } } This class ensures that our repositories have access to the database connection, our PDO, at any point. Now create a new file called \"Repository_Todoitem.php\" in the models folder and add the following code: <?php Class Repository_Todoitem extends Repository_Base { /** * fetch * * @param int $id * @return object */ function fetch(int $id) : object { $query = 'SELECT `id`, `content`, `state` FROM `todo` WHERE `id` = :id'; $statement = $this->db->prepare($query); $result = $statement->execute([':id' => $id]); if ($statement->rowCount() === 0) { throw new OutOfRangeException(); } $todoItem = $statement->fetchObject('Model_Todoitem'); return $todoItem; } /** * fetchAll * * @return array */ function fetchAll() : array { $query = 'SELECT `id`, `content`, `state` FROM `todo`'; $statement = $this->db->prepare($query); $result = $statement->execute(); $rows = $this->db->query($query)->fetchAll(PDO::FETCH_CLASS, 'Model_Todoitem'); return $rows; } /** * add * * @param mixed $form * @return bool */ function add($form) : bool { $query = 'INSERT INTO `todo` SET `content` = :content, `state` = :state'; $statement = $this->db->prepare($query); $result = $statement->execute([ ':content' => $form['content'], ':state' => $form['state'] ]); return $result; } /** * delete * * @param mixed $id * @return bool */ function delete($id) : bool { $query = 'DELETE FROM `todo` WHERE `id` = :id'; $statement = $this->db->prepare($query); $result = $statement->execute([':id' => $id]); return $result; } /** * update * * @param mixed $form * @return bool */ function update($form) : bool{ $query = 'UPDATE `todo` SET `content` = :content, `state` = :state WHERE `id` = :id'; $statement = $this->db->prepare($query); $result = $statement->execute([ ':id' => $form['id'], ':content' => $form['content'], ':state' => $form['state'] ]); return $result; } } All we do here is basically prepre our different statements for our CRUD functionality. Than we either fetch our object or objects, fill them in and return them. Or we provide data to the statements and call upon the database to either update an entry or delete it with it's id.","title":"Intregrating the Model into the Controller"},{"location":"app/#making-a-functional-view","text":"To now view our todos we need of cause the views to show them. For that I prepared three views. \"Todoitems_Page.php\" to view all of our entries. \"Todoentry_Page.php\" to view a single entry and edit or delete it. And \"Todoentry_Add_Page\" for making a new entry. Create these files in the views folder. Todoitems_Page: <!DOCTYPE html> <html lang=\"en\"> <head> <link rel=\"stylesheet\" href=\"/styles.css\"> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Todoitems</title> </head> <body> <?php foreach($entries as $entry) { if($entry->getState() == 1){ $done = '- done'; } else { $done = '- open'; } echo '<a class=\"box\" href=\"/Todolist/show/'.$entry->getId().'\">'.$entry- >getContent().' '.$done.'</a>'; } ?> <a href=\"/Todolist/add\">Neuer Eintrag</a> </body> </html> Todoentry_Page: <!DOCTYPE html> <html lang=\"en\"> <head> <link rel=\"stylesheet\" href=\"/styles.css\"> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Todoentry</title> </head> <body> <form method=\"POST\" action=\"/Todolist/edit/\" class=\"todoentry\"> <textarea id=\"todotext\" name=\"content\" rows=\"4\" cols=\"50\" autofocus><?php echo $content?></textarea> <span> done? <input type=\"checkbox\" name=\"state\" value=1 <?php if($state == 1) echo' checked' ?> > </span> <span> <input type=\"submit\" value=\"Save\"> <input type=\"hidden\" name=\"id\" value=\"<?=$id;?>\"> </span> </form> <form method=\"POST\" action=\"/Todolist/delete/\"> <input type=\"submit\" value=\"delete\"> <input type=\"hidden\" name=\"id\" value=\"<?=$id;?>\"> </form> </body> </html> Todoentry_Add_Page: <!DOCTYPE html> <html lang=\"en\"> <head> <link rel=\"stylesheet\" href=\"/styles.css\"> <meta charset=\"UTF-8\"> <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>New Entry</title> </head> <body> <h1>New Todo</h1> <form method=\"POST\"> <fieldset> <label> <span> Content <textarea id=\"todotext\" name=\"content\" rows=\"4\" cols=\"50\" autofocus></textarea> </span> <br> <span> Status <input type=\"checkbox\" name=\"state\" value=o> </span> </label> </fieldset> <input type=\"submit\" value=\"Save\"> </form> </body> </html> Now we have every thing in place for the Todoapp to work.","title":"Making a functional View"}]}